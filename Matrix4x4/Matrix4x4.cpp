#include "MATRIX4X4.h"

Matrix4x4::Matrix4x4()
{
    //ctor
}

Matrix4x4::~Matrix4x4()
{
    //dtor
}

void Matrix4x4::Diag4x4(float** A,float a,float b,float c,float d)
{
    A[0][0] = a;
    A[0][1] = 0.0f;
    A[0][2] = 0.0f;
    A[0][3] = 0.0f;

    A[1][0] = 0.0f;
    A[1][1] = b;
    A[1][2] = 0.0f;
    A[1][3] = 0.0f;

    A[2][0] = 0.0f;
    A[2][1] = 0.0f;
    A[2][1] = c;
    A[2][3] = 0.0f;

    A[3][0] = 0.0f;
    A[3][1] = 0.0f;
    A[3][2] = 0.0f;
    A[3][3] = d;
}

void Matrix4x4::Transpose4x4(float** A)
{
    float A01 = A[0][1];
    float A02 = A[0][2];
    float A03 = A[0][3];
    float A12 = A[1][2];
    float A13 = A[1][3];
    float A23 = A[2][3];

    A[0][1] = A[1][0];
    A[0][2] = A[2][0];
    A[0][3] = A[3][0];
    A[1][2] = A[2][1];
    A[1][3] = A[3][1];
    A[2][3] = A[3][2];

    A[1][0] = A01;
    A[2][0] = A02;
    A[3][0] = A03;
    A[2][1] = A12;
    A[3][1] = A13;
    A[3][2] = A23;

}

void Matrix4x4::Multiply4x4(float** A,float** B,float** Y)
{
    Y[0][0] = A[0][0]*B[0][0] + A[0][1]*B[1][0] + A[0][2]*B[2][0] + A[0][3]*B[3][0];
    Y[0][1] = A[0][0]*B[0][1] + A[0][1]*B[1][1] + A[0][2]*B[2][1] + A[0][3]*B[3][1];
    Y[0][2] = A[0][0]*B[0][2] + A[0][1]*B[1][2] + A[0][2]*B[2][2] + A[0][3]*B[3][2];
    Y[0][3] = A[0][0]*B[0][3] + A[0][1]*B[1][3] + A[0][2]*B[2][3] + A[0][3]*B[3][3];

    Y[1][0] = A[1][0]*B[0][0] + A[1][1]*B[1][0] + A[1][2]*B[2][0] + A[1][3]*B[3][0];
    Y[1][1] = A[1][0]*B[0][1] + A[1][1]*B[1][1] + A[1][2]*B[2][1] + A[1][3]*B[3][1];
    Y[1][2] = A[1][0]*B[0][2] + A[1][1]*B[1][2] + A[1][2]*B[2][2] + A[1][3]*B[3][2];
    Y[1][3] = A[1][0]*B[0][3] + A[1][1]*B[1][3] + A[1][2]*B[2][3] + A[1][3]*B[3][3];

    Y[2][0] = A[2][0]*B[0][0] + A[2][1]*B[1][0] + A[2][2]*B[2][0] + A[2][3]*B[3][0];
    Y[2][1] = A[2][0]*B[0][1] + A[2][1]*B[1][1] + A[2][2]*B[2][1] + A[2][3]*B[3][1];
    Y[2][2] = A[2][0]*B[0][2] + A[2][1]*B[1][2] + A[2][2]*B[2][2] + A[2][3]*B[3][2];
    Y[2][3] = A[2][0]*B[0][3] + A[2][1]*B[1][3] + A[2][2]*B[2][3] + A[2][3]*B[3][3];

    Y[3][0] = A[3][0]*B[0][0] + A[3][1]*B[1][0] + A[3][2]*B[2][0] + A[3][3]*B[3][0];
    Y[3][1] = A[3][0]*B[0][1] + A[3][1]*B[1][1] + A[3][2]*B[2][1] + A[3][3]*B[3][1];
    Y[3][2] = A[3][0]*B[0][2] + A[3][1]*B[1][2] + A[3][2]*B[2][2] + A[3][3]*B[3][2];
    Y[3][3] = A[3][0]*B[0][3] + A[3][1]*B[1][3] + A[3][2]*B[2][3] + A[3][3]*B[3][3];
}

void Matrix4x4::VectorMultiply4x4(float** A,float* B,float* Y)
{
    Y[0] = A[0][0]*B[0] + A[0][1]*B[1] + A[0][2]*B[2] + A[0][3]*B[3];
    Y[1] = A[1][0]*B[0] + A[1][1]*B[1] + A[1][2]*B[2] + A[1][3]*B[3];
    Y[2] = A[2][0]*B[0] + A[2][1]*B[1] + A[2][2]*B[2] + A[2][3]*B[3];
    Y[3] = A[3][0]*B[0] + A[3][1]*B[1] + A[3][2]*B[2] + A[3][3]*B[3];
}

bool Matrix4x4::Invert4x4(float** A,float** Y)
{
    float B[4][4],det;

    // Cofactor & Transpose

    B[0][0] =  ((A[1][1]*A[2][2]*A[3][3] + A[1][3]*A[2][1]*A[3][2] + A[1][2]*A[2][3]*A[3][1]) - (A[1][1]*A[2][3]*A[3][2] + A[1][2]*A[2][1]*A[3][3] + A[1][3]*A[2][2]*A[3][1]));
    B[1][0] = -((A[1][0]*A[2][2]*A[3][3] + A[1][2]*A[2][3]*A[3][0] + A[1][3]*A[2][0]*A[3][2]) - (A[1][0]*A[2][3]*A[3][2] + A[1][2]*A[2][0]*A[3][3] + A[1][3]*A[2][2]*A[3][0])); // Cofactor for B[0][1] transposed
    B[2][0] =  ((A[1][0]*A[2][1]*A[3][3] + A[1][1]*A[2][3]*A[3][0] + A[1][3]*A[2][0]*A[3][1]) - (A[1][0]*A[2][3]*A[3][1] + A[1][1]*A[2][0]*A[3][3] + A[1][3]*A[2][1]*A[3][0])); // Cofactor for B[0][2] transposed
    B[3][0] = -((A[1][0]*A[2][1]*A[3][2] + A[1][1]*A[2][2]*A[3][0] + A[1][2]*A[2][0]*A[3][1]) - (A[1][0]*A[2][2]*A[3][1] + A[1][1]*A[2][0]*A[3][2] + A[1][2]*A[2][1]*A[3][0])); // Cofactor for B[0][3] transposed

    B[0][1] = -((A[0][1]*A[2][2]*A[3][3] + A[0][2]*A[2][3]*A[3][1] + A[0][3]*A[2][1]*A[3][2]) - (A[0][1]*A[2][3]*A[3][2] + A[0][2]*A[2][1]*A[3][3] + A[0][3]*A[2][2]*A[3][1]));
    B[1][1] =  ((A[0][0]*A[2][2]*A[3][3] + A[0][2]*A[2][3]*A[3][0] + A[0][3]*A[2][0]*A[3][2]) - (A[0][0]*A[2][3]*A[3][2] + A[0][2]*A[2][0]*A[3][3] + A[0][3]*A[2][2]*A[3][0]));
    B[2][1] = -((A[0][0]*A[2][1]*A[3][3] + A[0][1]*A[2][3]*A[3][0] + A[0][3]*A[2][0]*A[3][1]) - (A[0][0]*A[2][3]*A[3][1] + A[0][1]*A[2][0]*A[3][3] + A[0][3]*A[2][1]*A[3][0]));
    B[3][1] =  ((A[0][0]*A[2][1]*A[3][2] + A[0][1]*A[2][2]*A[3][0] + A[0][2]*A[2][0]*A[3][1]) - (A[0][0]*A[2][2]*A[3][1] + A[0][1]*A[2][0]*A[3][2] + A[0][2]*A[2][1]*A[3][0]));

    B[0][2] =   (A[0][1]*A[1][2]*A[3][3] + A[0][2]*A[1][3]*A[3][1] + A[0][3]*A[1][1]*A[3][2]) - (A[0][1]*A[1][3]*A[3][2] + A[0][2]*A[1][1]*A[3][3] + A[0][3]*A[1][2]*A[3][1]);
    B[1][2] = -((A[0][0]*A[1][2]*A[3][3] + A[0][2]*A[1][3]*A[3][0] + A[0][3]*A[1][0]*A[3][2]) - (A[0][0]*A[1][3]*A[3][2] + A[0][2]*A[1][0]*A[3][3] + A[0][3]*A[1][2]*A[3][0]));
    B[2][2] =   (A[0][0]*A[1][1]*A[3][3] + A[0][1]*A[1][3]*A[3][0] + A[0][3]*A[1][0]*A[3][1]) - (A[0][0]*A[1][3]*A[3][1] + A[0][1]*A[1][0]*A[3][3] + A[0][3]*A[1][1]*A[3][0]);
    B[3][2] = -((A[0][0]*A[1][1]*A[3][2] + A[0][1]*A[1][2]*A[3][0] + A[0][2]*A[1][0]*A[3][1]) - (A[0][0]*A[1][2]*A[3][1] + A[0][1]*A[1][0]*A[3][2] + A[0][2]*A[1][1]*A[3][0]));

    B[0][3] = -((A[0][1]*A[1][2]*A[2][3] + A[0][2]*A[1][3]*A[2][1] + A[0][3]*A[1][1]*A[2][2]) - (A[0][1]*A[1][3]*A[2][2] + A[0][2]*A[1][1]*A[2][3] + A[0][3]*A[1][2]*A[2][1]));
    B[1][3] =  ((A[0][0]*A[1][2]*A[2][3] + A[0][2]*A[1][3]*A[2][0] + A[0][3]*A[1][0]*A[2][2]) - (A[0][0]*A[1][3]*A[2][2] + A[0][2]*A[1][0]*A[2][3] + A[0][3]*A[1][2]*A[2][0]));
    B[2][3] = -((A[0][0]*A[1][1]*A[2][3] + A[0][1]*A[1][3]*A[2][0] + A[0][3]*A[1][0]*A[2][1]) - (A[0][0]*A[1][3]*A[2][1] + A[0][1]*A[1][0]*A[2][3] + A[0][3]*A[1][1]*A[2][0]));
    B[3][3] =  ((A[0][0]*A[1][1]*A[2][2] + A[0][1]*A[1][2]*A[2][0] + A[0][2]*A[1][0]*A[2][1]) - (A[0][0]*A[1][2]*A[2][1] + A[0][1]*A[1][0]*A[2][2] + A[0][2]*A[1][1]*A[2][0]));

    // Calculate Determinant (Using Pre Transposed Cofactors)

    det = A[0][0]*B[0][0] + A[0][1]*B[1][0] + A[0][2]*B[2][0] + A[0][3]*B[3][0];

    if(det==0.0f)
    {
        return false;
    }  else
        {
            Y[0][0] = B[0][0] / det;
            Y[0][1] = B[0][1] / det;
            Y[0][2] = B[0][2] / det;
            Y[0][3] = B[0][3] / det;

            Y[1][0] = B[1][0] / det;
            Y[1][1] = B[1][1] / det;
            Y[1][2] = B[1][2] / det;
            Y[1][3] = B[1][3] / det;

            Y[2][0] = B[2][0] / det;
            Y[2][1] = B[2][1] / det;
            Y[2][2] = B[2][2] / det;
            Y[2][3] = B[2][3] / det;

            Y[3][0] = B[3][0] / det;
            Y[3][1] = B[3][1] / det;
            Y[3][2] = B[3][2] / det;
            Y[3][3] = B[3][3] / det;
            return true;
        }
}

float Matrix4x4::Determinant4x4(float** A)
{
    float B[4];

    // Cofactor

    B[0] =   (A[1][1]*A[2][2]*A[3][3] + A[1][3]*A[2][1]*A[3][2] + A[1][2]*A[2][3]*A[3][1]) - (A[1][1]*A[2][3]*A[3][2] + A[1][2]*A[2][1]*A[3][3] + A[1][3]*A[2][2]*A[3][1]);
    B[1] = -((A[1][0]*A[2][2]*A[3][3] + A[1][2]*A[2][3]*A[3][0] + A[1][3]*A[2][0]*A[3][2]) - (A[1][0]*A[2][3]*A[3][2] + A[1][2]*A[2][0]*A[3][3] + A[1][3]*A[2][2]*A[3][0]));
    B[2] =   (A[1][0]*A[2][1]*A[3][3] + A[1][1]*A[2][3]*A[3][0] + A[1][3]*A[2][0]*A[3][1]) - (A[1][0]*A[2][3]*A[3][1] + A[1][1]*A[2][0]*A[3][3] + A[1][3]*A[2][1]*A[3][0]);
    B[3] = -((A[1][0]*A[2][1]*A[3][2] + A[1][1]*A[2][2]*A[3][0] + A[1][2]*A[2][0]*A[3][1]) - (A[1][0]*A[2][2]*A[3][1] + A[1][1]*A[2][0]*A[3][2] + A[1][2]*A[2][1]*A[3][0]));

    // Calculate Determinant

    return (A[0][0]*B[0] + A[0][1]*B[1] + A[0][2]*B[2] + A[0][3]*B[3]);
}
